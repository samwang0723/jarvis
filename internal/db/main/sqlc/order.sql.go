// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: order.sql

package sqlcdb

import (
	"context"

	uuid "github.com/gofrs/uuid/v5"
)

const GetOrder = `-- name: GetOrder :one
SELECT id, user_id, stock_id, buy_price, buy_quantity, buy_exchange_date, sell_price, sell_quantity, sell_exchange_date, profitable_price, status, version, created_at, updated_at
FROM orders
WHERE id = $1
`

func (q *Queries) GetOrder(ctx context.Context, id uuid.UUID) (*Order, error) {
	row := q.db.QueryRow(ctx, GetOrder, id)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.StockID,
		&i.BuyPrice,
		&i.BuyQuantity,
		&i.BuyExchangeDate,
		&i.SellPrice,
		&i.SellQuantity,
		&i.SellExchangeDate,
		&i.ProfitablePrice,
		&i.Status,
		&i.Version,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const ListOpenOrders = `-- name: ListOpenOrders :many
SELECT id 
FROM orders 
WHERE user_id = $1 
  AND stock_id = $2 
  AND status IN ('created', 'changed') 
  AND (
    ($3::VARCHAR = 'Sell' AND buy_quantity - sell_quantity > 0) 
    OR 
    ($3::VARCHAR = 'Buy' AND sell_quantity - buy_quantity > 0)
  )
ORDER BY created_at ASC
`

type ListOpenOrdersParams struct {
	UserID    uuid.UUID
	StockID   string
	OrderType string
}

func (q *Queries) ListOpenOrders(ctx context.Context, arg *ListOpenOrdersParams) ([]uuid.UUID, error) {
	rows, err := q.db.Query(ctx, ListOpenOrders, arg.UserID, arg.StockID, arg.OrderType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []uuid.UUID
	for rows.Next() {
		var id uuid.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListOrders = `-- name: ListOrders :many
SELECT id, user_id, stock_id, buy_price, buy_quantity, buy_exchange_date, sell_price, sell_quantity, sell_exchange_date, profitable_price, status, version, created_at, updated_at
FROM orders
WHERE user_id = $1
  AND (stock_id = ANY($4::text[]) OR NOT $5::bool)
  AND ($6::VARCHAR = '' OR status = $6)
  AND ($7::VARCHAR = '' 
    OR sell_exchange_date LIKE $7::VARCHAR || '%' 
    OR buy_exchange_date LIKE $7::VARCHAR || '%')
LIMIT $2 OFFSET $3
`

type ListOrdersParams struct {
	UserID          uuid.UUID
	Limit           int32
	Offset          int32
	StockIds        []string
	FilterByStockID bool
	Status          string
	ExchangeMonth   string
}

func (q *Queries) ListOrders(ctx context.Context, arg *ListOrdersParams) ([]*Order, error) {
	rows, err := q.db.Query(ctx, ListOrders,
		arg.UserID,
		arg.Limit,
		arg.Offset,
		arg.StockIds,
		arg.FilterByStockID,
		arg.Status,
		arg.ExchangeMonth,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.StockID,
			&i.BuyPrice,
			&i.BuyQuantity,
			&i.BuyExchangeDate,
			&i.SellPrice,
			&i.SellQuantity,
			&i.SellExchangeDate,
			&i.ProfitablePrice,
			&i.Status,
			&i.Version,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpsertOrder = `-- name: UpsertOrder :exec
INSERT INTO orders (id, user_id, stock_id, buy_price, buy_quantity,
buy_exchange_date, sell_price, sell_quantity, sell_exchange_date, profitable_price,
status, version)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
ON CONFLICT (id) DO UPDATE
SET user_id = EXCLUDED.user_id, 
  stock_id = EXCLUDED.stock_id,
  buy_price = EXCLUDED.buy_price, 
  buy_quantity = EXCLUDED.buy_quantity, 
  buy_exchange_date = EXCLUDED.buy_exchange_date,
  sell_price = EXCLUDED.sell_price, 
  sell_quantity = EXCLUDED.sell_quantity, 
  sell_exchange_date = EXCLUDED.sell_exchange_date,
  profitable_price = EXCLUDED.profitable_price, 
  status = EXCLUDED.status, 
  version = EXCLUDED.version
`

type UpsertOrderParams struct {
	ID               uuid.UUID
	UserID           uuid.UUID
	StockID          string
	BuyPrice         float64
	BuyQuantity      int64
	BuyExchangeDate  string
	SellPrice        float64
	SellQuantity     int64
	SellExchangeDate string
	ProfitablePrice  float64
	Status           string
	Version          int32
}

func (q *Queries) UpsertOrder(ctx context.Context, arg *UpsertOrderParams) error {
	_, err := q.db.Exec(ctx, UpsertOrder,
		arg.ID,
		arg.UserID,
		arg.StockID,
		arg.BuyPrice,
		arg.BuyQuantity,
		arg.BuyExchangeDate,
		arg.SellPrice,
		arg.SellQuantity,
		arg.SellExchangeDate,
		arg.ProfitablePrice,
		arg.Status,
		arg.Version,
	)
	return err
}
