// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: daily_close.sql

package sqlcdb

import (
	"context"
	"database/sql"
	"time"

	"github.com/ericlagergren/decimal"
	uuid "github.com/gofrs/uuid/v5"
)

const BatchUpsertDailyClose = `-- name: BatchUpsertDailyClose :exec
INSERT INTO daily_closes (
    stock_id, exchange_date, trade_shares, transactions, turnover, open, close, high, low, price_diff
  ) VALUES (
    unnest($1::varchar[]), 
    unnest($2::varchar[]), 
    unnest($3::bigint[]), 
    unnest($4::bigint[]), 
    unnest($5::bigint[]),
    unnest($6::numeric[]),
    unnest($7::numeric[]),
    unnest($8::numeric[]),
    unnest($9::numeric[]),
    unnest($10::numeric[])
  )
ON CONFLICT (stock_id, exchange_date) DO UPDATE SET
    trade_shares = EXCLUDED.trade_shares,
    transactions = EXCLUDED.transactions,
    turnover = EXCLUDED.turnover,
    open = EXCLUDED.open,
    close = EXCLUDED.close,
    high = EXCLUDED.high,
    low = EXCLUDED.low,
    price_diff = EXCLUDED.price_diff
`

type BatchUpsertDailyCloseParams struct {
	StockID      []string
	ExchangeDate []string
	TradeShares  []int64
	Transactions []int64
	Turnover     []int64
	Open         []decimal.Big
	Close        []decimal.Big
	High         []decimal.Big
	Low          []decimal.Big
	PriceDiff    []decimal.Big
}

func (q *Queries) BatchUpsertDailyClose(ctx context.Context, arg *BatchUpsertDailyCloseParams) error {
	_, err := q.db.Exec(ctx, BatchUpsertDailyClose,
		arg.StockID,
		arg.ExchangeDate,
		arg.TradeShares,
		arg.Transactions,
		arg.Turnover,
		arg.Open,
		arg.Close,
		arg.High,
		arg.Low,
		arg.PriceDiff,
	)
	return err
}

const CreateDailyClose = `-- name: CreateDailyClose :exec
INSERT INTO daily_closes (
    stock_id, exchange_date, trade_shares, transactions, turnover, open, close, high, low, price_diff
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
)
`

type CreateDailyCloseParams struct {
	StockID      string
	ExchangeDate string
	TradeShares  sql.NullInt64
	Transactions sql.NullInt64
	Turnover     sql.NullInt64
	Open         decimal.Big
	Close        decimal.Big
	High         decimal.Big
	Low          decimal.Big
	PriceDiff    decimal.Big
}

func (q *Queries) CreateDailyClose(ctx context.Context, arg *CreateDailyCloseParams) error {
	_, err := q.db.Exec(ctx, CreateDailyClose,
		arg.StockID,
		arg.ExchangeDate,
		arg.TradeShares,
		arg.Transactions,
		arg.Turnover,
		arg.Open,
		arg.Close,
		arg.High,
		arg.Low,
		arg.PriceDiff,
	)
	return err
}

const HasDailyClose = `-- name: HasDailyClose :one
SELECT EXISTS (
    SELECT 1 FROM daily_closes
    WHERE exchange_date = $1
)
`

func (q *Queries) HasDailyClose(ctx context.Context, exchangeDate string) (bool, error) {
	row := q.db.QueryRow(ctx, HasDailyClose, exchangeDate)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const ListDailyClose = `-- name: ListDailyClose :many
SELECT t.id, t.stock_id, t.exchange_date, t.transactions,
       FLOOR(t.trade_shares/1000) AS trade_shares, FLOOR(t.turnover/1000) AS turnover,
       t.open, t.high, t.close, t.low, t.price_diff, t.created_at, t.updated_at, t.deleted_at
FROM (
    SELECT daily_closes.id FROM daily_closes
    WHERE daily_closes.exchange_date >= $3 AND daily_closes.stock_id = $4
    AND ($5::text = '' OR daily_closes.exchange_date <= $5::text)
    ORDER BY daily_closes.exchange_date DESC
    LIMIT $1 OFFSET $2
) q
JOIN daily_closes t ON t.id = q.id
`

type ListDailyCloseParams struct {
	Limit     int32
	Offset    int32
	StartDate string
	StockID   string
	EndDate   string
}

type ListDailyCloseRow struct {
	ID           uuid.UUID
	StockID      string
	ExchangeDate string
	Transactions sql.NullInt64
	TradeShares  float64
	Turnover     float64
	Open         decimal.Big
	High         decimal.Big
	Close        decimal.Big
	Low          decimal.Big
	PriceDiff    decimal.Big
	CreatedAt    time.Time
	UpdatedAt    time.Time
	DeletedAt    sql.NullTime
}

func (q *Queries) ListDailyClose(ctx context.Context, arg *ListDailyCloseParams) ([]*ListDailyCloseRow, error) {
	rows, err := q.db.Query(ctx, ListDailyClose,
		arg.Limit,
		arg.Offset,
		arg.StartDate,
		arg.StockID,
		arg.EndDate,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListDailyCloseRow
	for rows.Next() {
		var i ListDailyCloseRow
		if err := rows.Scan(
			&i.ID,
			&i.StockID,
			&i.ExchangeDate,
			&i.Transactions,
			&i.TradeShares,
			&i.Turnover,
			&i.Open,
			&i.High,
			&i.Close,
			&i.Low,
			&i.PriceDiff,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListLatestPrice = `-- name: ListLatestPrice :many
WITH RankedCloses AS (
    SELECT 
        daily_closes.stock_id,
        daily_closes.close,
        daily_closes.exchange_date,
        ROW_NUMBER() OVER (PARTITION BY daily_closes.stock_id ORDER BY daily_closes.exchange_date DESC) AS rn
    FROM 
        daily_closes
    WHERE 
        daily_closes.stock_id = ANY($1::text[])
)
SELECT 
    RankedCloses.stock_id,
    RankedCloses.close,
    RankedCloses.exchange_date
FROM 
    RankedCloses
WHERE 
    rn = 1
`

type ListLatestPriceRow struct {
	StockID      string
	Close        decimal.Big
	ExchangeDate string
}

func (q *Queries) ListLatestPrice(ctx context.Context, stockIds []string) ([]*ListLatestPriceRow, error) {
	rows, err := q.db.Query(ctx, ListLatestPrice, stockIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListLatestPriceRow
	for rows.Next() {
		var i ListLatestPriceRow
		if err := rows.Scan(&i.StockID, &i.Close, &i.ExchangeDate); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
